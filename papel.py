# -*- coding: utf-8 -*-
"""Test Calculado Mezclado a PAPEL v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WscBC1ZVeLCZxEnAItoE1jySyyXW19VL
"""

'''
**Programa generador de tests aleatorios**
Javier Fernández Panadero 09-12-2021
javierfpanadero@yahoo.com

Funcionamiento:

- Mezcla preguntas (número arbitrario)
- Mezcla respuestas (número arbitrario)
- Admite preguntas multilínea (OPCIONAL)
- Admite valores aleatorios y cálculos con ellos en enunciados y respuestas. (OPCIONAL)

1. La ejecución del primer bloque te pide que subas un fichero.
2. La ejecución del segundo bloque crea el test y lo imprime en pantalla
3. La ejecución del tercer bloque descarga el test como output.txt


Ejemplo de fichero formateado con todas las posibilidades:

entero,x,20,25
real,y,0.3,0.4
lista,z,2,4,6,8
@@@@

Pregunta 1 @@ x @@, @@ z @@
Respuesta 1a x/z @@ x/z @@
Respuesta 1b
Respuesta 1c

Pregunta 2 @@ y @@
Pregunta 2 (segunda linea)
+++p
Respuesta 2a y*2 @@ y*2 @@
Respuesta 2b
Respuesta 2c
Respuesta 2d

Explicación del formato:
Cabecera opcional
- Para enteros y reales
tipo de variable, nombre de variable, valor mínimo, valor máximo
- Para listas (se transformarán en reales)
tipo de variable, nombre de variable, valor1, valor2...

@@@@ marca que hay una cabecera encima de ello. (Dejad después línea en blanco)

Los valores a calcular se enmarcan con dos arrobas y un espacio, por ej: @@ x*y @@

A partir de ahí las preguntas en cualquier número y con cualquier número de opciones

Si la pregunta tiene más de una línea poner debajo de ella +++p

No se admiten respuestas de más de una línea

La primera respuesta que aparece se tomará como correcta.

No dejéis líneas en blanco al final del texto origen.

'''

# Sólo ejecutar si se va a subir el archivo
from google.colab import files

uploaded = files.upload()
file = uploaded.popitem()[0]   # Se podrían haber selecciondo varios archivos para elegir, cogemos el primero usando la posición 0

with open(file,'r') as archivo:
  texto_completo = archivo.read()

print(texto_completo)

#with open('PruebaExamenAleatorio.txt','r') as f:   #Si cargamos fichero
    #texto_completo = f.read()

import random
import re        #para usar expresiones regulares
import math

#Buscamos si hay cabecera con variables y la procesamos

marca_def = '\n@@@@\n\n'

if marca_def in texto_completo:
    rompe_cabecera = texto_completo.split(marca_def)  #separa cabecera y texto
    cabecera = rompe_cabecera[0]
    texto = rompe_cabecera[1]
    
    lineas = cabecera.split('\n')
    variables = []
    for linea in lineas:
        elementos = linea.split(',')
        variables.append(elementos)
    for variable in variables:
        if variable[0] == 'entero':
            min = int(variable[2])
            max = int(variable[3])
            valor = random.randint(min,max)       #un entero entre los valores máximo y mínimo
            exec("%s = %d" % (variable[1],valor)) #asignamos el valor al nombre elegido por el usuario para la variable
        if variable[0] == 'real':
            min = float(variable[2])
            max = float(variable[3])
            valor = random.uniform(min,max)       #un float entre en mín incluido y el máximo sin incluir
            exec("%s = %f" % (variable[1],valor)) #asignamos el valor al nombre elegido por el usuario para la variable
        if variable[0] == 'lista':
            elegibles = variable[2:]
            for i in range(len(elegibles)):
                elegibles[i] = int(elegibles[i])
            valor = random.choice(elegibles)      #valores entre una lista
            exec("%s = %d" % (variable[1],valor)) #asignamos el valor al nombre elegido por el usuario para la variable

    # REEMPLAZAMIENTO
    
    #Buscamos cualquier cadena entre las marcas @@+espacio que serán las expresiones a evaluar
    
    ocurrencias = re.findall('@@ (.+?) @@', texto)
    #print(ocurrencias)

    #Creamos un diccionario con las ocurrencias y su valor (eval es una función "insegura" pero aquí la usa el usuario solo)
    
    reemplazador={}
    for ocurrencia in ocurrencias:
        reemplazador[ocurrencia] = eval(ocurrencia)
    
    #Si queremos que los resultados salgan ajustados por cifras significativas
    
    def ajuste(x,n):
        m = math.ceil(math.log10(x))   #con log10 sabré hasta dónde hay que redondear para quedarse con n cifras
        resultado = round(x,n-m)
        return resultado

    print(reemplazador)
   
    for key, value in reemplazador.items():
        reemplazador[key] = ajuste(value,3)     # TRES cifras significativas

    print(reemplazador)

    #Llevamos a cabo todos los reemplazos en el texto del examen
    
    for clave, valor in reemplazador.items():
        texto = texto.replace('@@ '+clave+' @@', str(valor))
    
    texto_completo = texto
#print(texto_completo)

#Separamos el texto en preguntas

texto_preguntas=texto_completo.split(sep='\n\n')    #separo el texto en preguntas 

#print (texto_preguntas)   

#Separamos las respuestas del enunciado, teniendo en cuenta si hay enunciados multilínea

marca_pregunta = '+++p\n'

examen_inicial=[]
for pregunta in texto_preguntas:
    if marca_pregunta in pregunta:                      #si la pregunta es multilínea
        primercorte = pregunta.split(marca_pregunta)    #separamos la pregunta
        enunciado = primercorte.pop(0)                  #extraemos la pregunta
        segundocorte = primercorte[0].split('\n')       #separamos las respuestas
        segundocorte.insert(0, enunciado[:-1])          #añadimos el enunciado sin el último cambio de línea
        examen_inicial.append(segundocorte)
        #print(examen_inicial)
    else:
        segundocorteB = pregunta.split('\n')            #separamos pregunta y respuestas
        examen_inicial.append(segundocorteB)            #examen como lista de listas. Primer elemento pregunta.

#print(examen_inicial)



#mezclado de respuestas

examen_modificado = []

for pregunta in examen_inicial:
    pregunta[1]='$$$'+pregunta[1]    #marco la respuesta correcta
    respuestas=pregunta[1:]          #sacamos la pregunta   
    random.shuffle(respuestas)       #mezclamos las respuestas
    respuestas.insert(0,pregunta[0]) #añadimos la pregunta de nuevo
    pregunta = respuestas
    examen_modificado.append(pregunta)

#mezclamos las preguntas

random.shuffle(examen_modificado)       

#clave para corregir
abecedario='abcdefghijklmnopqrstuvwxyz'
key=[]
for i, pregunta in enumerate(examen_modificado):
    for j, respuestas in enumerate(pregunta):
        if pregunta[j].startswith('$$$'):          #buscamos la respuesta correcta
            pregunta[j]=pregunta[j][3:]            #quitamos la marca
            key.append([str(i+1),abecedario[j-1]]) #anotamos su posición
            break

#escribimos el test de salida
test=''

for i, pregunta in enumerate(examen_modificado):
    for j, respuestas in enumerate(pregunta):
        if j == 0:
            test+= str(i+1)+'. '+ pregunta[0]+'\n'
        else:
            test+= abecedario[j-1]+') '+pregunta[j]+'\n'
    test+= '\n'


#añadimos la clave

test+= '\n'*5 +'CLAVE'

for i in range(len(key)):
    test += '\n'
    for j in range(len(key[i])):
        test += key[i][j]

print(test)

# Descargamos el archivo de salida
salida = "output.txt"   # Puede cambiarse a otro nombre

with open(salida,"w") as archivo:
  archivo.write(test)

files.download(salida)