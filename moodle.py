# -*- coding: utf-8 -*-
"""Copia de XML Moodle Preguntas múltiple calculada.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_VxcfI622PuqUIMslEJfEb9fkFOjbJ4Z
"""

#Cargamos el archivo

from google.colab import files

uploaded = files.upload()
file = uploaded.popitem()[0]   # Se podrían haber selecciondo varios archivos para elegir, cogemos el primero usando la posición 0

with open(file,'r') as archivo:
  texto_completo = archivo.read()

#print(texto_completo)

'''Genera Preguntas Calculadas en XML para subir a Moodle

Javier Fernández Panadero
10-12-2021
javierfpanadero@yahoo.com
http://lacienciaparatodos.wordpress.com

Funcionamiento:
Se parte de un archivo de texto de formato sencillo (ejemplo más abajo)
Se genera un archivo XML para importarlo a Moodle
Se convertirán en preguntas de respuesta múltiple calculadas

Características:
- Número de preguntas arbitrario
- Número de respuestas arbitrario
- Se permite pregunta multilínea (hay que acabar con una marca +++p)
- Se pueden usar valores variables en cada pregunta o respuesta, que pueden ser:
1. Enteros en un rango
2. Decimales en un rango
3. Una lista de valores concretos (decimales)

ADVERTENCIAS
1. El nombre de una variable no puede estar contenida en otra, por ejemplo x1 y x12, úsese x01, x02.., x10, x11..
2. Las variables tomarán diez valores, para que las listas sean al menos así de largas, el programa alargará la lista repitiendo los valores que hayas puesto

Ejemplo de examen:

entero,x1,20,25
real,x2,0.3,0.4
lista,x3,2,4,6,8
@@@@

Pregunta 1 @@ x1 @@, @@ x3 @@
Respuesta 1a x1/x3 @@ x1/x3 @@
Respuesta 1b
Respuesta 1c

Pregunta 2 @@ x2 @@
Pregunta 2 (segunda linea)
+++p
Respuesta 2a x2*2 @@ x2*2 @@
Respuesta 2b
Respuesta 2c
Respuesta 2d

EXPLICACIÓN DEL FORMATO DE EXAMEN
"Cabecera"
tipo (entero/real), nombre, valor inicial, valor filter
tipo lista, nombre, valor1, valor2...
Se termina con una línea con la marca @@@@ y una línea en blanco.
"Cuerpo"
- Preguntas separadas por una línea en blanco
- Enunciado seguido de las respuestas en las líneas siguientes
- Se toma como correcta la primera respuesta
- Si el enunciado tiene más de una línea se pone al final del enunciado una línea con la marca +++p
No poner líneas en blanco al final del archivo.
"Valores calculados"
Se ponen netre dos arrobas y espacio y el programa sustituirá lo que se ponga por su valor

Código XML de ejemplo tomado de:
https://www.lambdasolutions.net/knowledgehub/question-type-xml-format#calculated-simple
Referencia Moodle XML https://docs.moodle.org/311/en/Moodle_XML_format

Código XML ejemplo:
<?xml version="1.0" encoding="UTF-8"?>
<quiz>
<!-- question: 50  -->
  <question type="calculatedsimple">
    <name>
      <text>Calculated simple test</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p>If I have {kittens} kittens and pet insurance costs £5 per animal - how much do I have to spend on pet insurance in total?<br></p>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>1.0000000</defaultgrade>
    <penalty>0.3333333</penalty>
    <hidden>0</hidden>
    <synchronize>0</synchronize>
    <single>0</single>
    <answernumbering>abc</answernumbering>
    <shuffleanswers>0</shuffleanswers>
    <correctfeedback>
      <text></text>
    </correctfeedback>
    <partiallycorrectfeedback>
      <text></text>
    </partiallycorrectfeedback>
    <incorrectfeedback>
      <text></text>
    </incorrectfeedback>
<answer fraction="100">
    <text>{kittens}*5</text>
    <tolerance>0.01</tolerance>
    <tolerancetype>1</tolerancetype>
    <correctanswerformat>1</correctanswerformat>
    <correctanswerlength>0</correctanswerlength>
    <feedback format="html">
    <text></text>
    </feedback>
</answer>
    <unitgradingtype>0</unitgradingtype>
    <unitpenalty>0.1000000</unitpenalty>
    <showunits>3</showunits>
    <unitsleft>0</unitsleft>
<dataset_definitions>
<dataset_definition>
    <status><text>private</text>
</status>
    <name><text>kittens</text>
</name>
    <type>calculatedsimple</type>
    <distribution><text>uniform</text>
</distribution>
    <minimum><text>1.0</text>
</minimum>
    <maximum><text>10.0</text>
</maximum>
    <decimals><text>1</text>
</decimals>
    <itemcount>10</itemcount>
    <dataset_items>
        <dataset_item>
           <number>1</number>
           <value>8</value>
        </dataset_item>
        <dataset_item>
           <number>2</number>
           <value>5</value>
        </dataset_item>
        <dataset_item>
           <number>3</number>
           <value>6</value>
        </dataset_item>
        <dataset_item>
           <number>4</number>
           <value>2</value>
        </dataset_item>
        <dataset_item>
           <number>5</number>
           <value>6</value>
        </dataset_item>
        <dataset_item>
           <number>6</number>
           <value>3</value>
        </dataset_item>
        <dataset_item>
           <number>7</number>
           <value>1</value>
        </dataset_item>
        <dataset_item>
           <number>8</number>
           <value>6</value>
        </dataset_item>
        <dataset_item>
           <number>9</number>
           <value>3</value>
        </dataset_item>
        <dataset_item>
           <number>10</number>
           <value>5</value>
        </dataset_item>
    </dataset_items>
    <number_of_items>10</number_of_items>
</dataset_definition>
</dataset_definitions>
  </question>

</quiz>

EXPLICACIÓN ETIQUETAS

Tipo de pregunta
<question type="calculatedsimple">
Debe ser calculatedmulti

Nombre de la pregunta (por defecto, el enunciado)
<name>

Formato enunciado (por defecto html)
<questiontext format="html">
*Importante usar CDATA para que las etiquetas html no interfieran con el exterior XML

Feedback general (por defecto, none)
<generalfeedback format="html">

Puntuación por defecto de la pregunta
<defaultgrade>1.0000000</defaultgrade>

Penalización por intento incorrecto
<penalty>0.3333333</penalty>

???????
<hidden>0</hidden>

Sincronización con otros valores de variables
<synchronize>0</synchronize>

True/False
<single>0</single>

Tipo de numeración
<answernumbering>abc</answernumbering>

Mezcla de respuestas
<shuffleanswers>0</shuffleanswers>

Otros Feedback
<correctfeedback>
<partiallycorrectfeedback>
<incorrectfeedback>

Porcentaje de puntuación
<answer fraction="100">

Manera de incluir las variables
{kittens}*5

Tolerancia
<tolerance>0.01</tolerance>

Tolerancia relativa, en lugar de absoluta
<tolerancetype>1</tolerancetype>

Decimales, en lugar de cifras significativas
<correctanswerformat>1</correctanswerformat>

Número de decimales/cifras significativas
<correctanswerlength>0</correctanswerlength>

Cómo se introducen las unidades (0 input, 1 radio, 2 select)
<unitgradingtype>0</unitgradingtype>

Penalización por unidad incorrecta
<unitpenalty>0.1000000</unitpenalty>

Calificación de unidades (3 none, 1 graded, 0 optional)
<showunits>3</showunits>

En qué posición se ponen las unidades
<unitsleft>0</unitsleft>

Hay que meterle un dataset previo para que no haya que pedir recalcular a mano.
Lo podemos generar con Python

'''
#------------------PROGRAMA--------------------#

print('''
PROGRAMA PARA CREAR XML A PARTIR DE EXAMEN EN txt
''')

#Cargamos las librerías necesarias

import random
import re        #para usar expresiones regulares
import math

#Buscamos si hay cabecera con variables y la procesamos

marca_def = '\n@@@@\n\n'

if marca_def in texto_completo:

  rompe_cabecera = texto_completo.split(marca_def)  #separa cabecera y texto
  cabecera = rompe_cabecera[0]
  texto = rompe_cabecera[1]
      
  lineas = cabecera.split('\n')
  variables = []
  for linea in lineas:
      elementos = linea.split(',')
      variables.append(elementos)
  #print(variables)
      
  data = []     

  '''
  Si el tamaño de los datasets y de las listas que haya no son iguales,
  Moodle tomará el tamaño menor para generar las distintas preguntas.
  Así que alargaremos las listas, si son más cortas que la longitud de las series,
  repitiendo elementos hasta que sean al menos igual de largas. 
  '''

  longitud_serie = 10     #esta será la longitud máxima de los datasets


  for variable in variables:
        
      if variable[0] == 'entero':
          valor = [variable[1]]
          numericos = list(map(int, variable[2:4])) #map aplica una función sobre un iterable (hay que pasar a lista)
          valor += numericos
          #print(valor)
          minimo = valor[1]
          maximo = valor[2]                
          for i in range(longitud_serie): 
              valor.append(random.randint(minimo,maximo))     #enteros entre los valores máximo y mínimo
          data.append(valor)
      
      if variable[0] == 'real':
          valor = [variable[1]]
          numericos = list(map(float, variable[2:4])) #map aplica una función sobre un iterable (hay que pasar a lista)
          valor += numericos
          minimo = valor[1]
          maximo = valor[2]                         #guardamos los valores max y mín
          for i in range(longitud_serie):
              x = random.uniform(minimo,maximo)
              decimales_para_significativas = 2+math.ceil(-(math.log10(x)))           #así ajustamos los reales a 3 cifras significativas
              x = round(x, decimales_para_significativas)
              valor.append(x)    #float entre en mín incluido y el máximo sin incluir               
          data.append(valor)
          
      if variable[0] == 'lista':
          elegibles = variable[2:]
          elegibles = list(map(float, elegibles))          #map aplica una función sobre un iterable, hay q convertirlo en lista      
          max_elegibles = max(elegibles)
          min_elegibles = min(elegibles)

          if len(elegibles) < longitud_serie:              #aumentamos las listas hasta tener más longitud que las series
            k = longitud_serie // len(elegibles)
            elegibles += elegibles*k

          longitud_serie_lista = len(elegibles)            #longitud de la lista de datos              
          
          valor = [variable[1], min_elegibles, max_elegibles]+elegibles
          data.append(valor)

  #print(data) 
  #print(longitud_serie)
  #print(longitud_serie_lista)
          

  #Reemplazamos las ocurrencias

  #print(texto)

  ocurrencias = re.findall('@@ (.+?) @@', texto)    #Buscamos cualquier cadena entre las marcas @@+espacio que serán las expresiones a evaluar

  #print(ocurrencias)
  
  for i in range(len(ocurrencias)):
      for variable in variables:
          ocurrencias[i] = ocurrencias[i].replace(variable[1],'{'+variable[1]+'}')

  #print(ocurrencias)   
      
  for i in range(len(ocurrencias)):
      ocurrencias[i] = '{=' + ocurrencias[i] + '}'
      
  #print(ocurrencias)   

  #print(texto)

  for i in range(len(ocurrencias)):
      texto = re.sub('@@ (.+?) @@', ocurrencias[i], texto, 1)

else:
  texto = texto_completo  

#print(texto)

#Separamos el texto en preguntas

texto_preguntas=texto.split(sep='\n\n')    #separo el texto en preguntas 

#print (texto_preguntas)   

#Separamos las respuestas del enunciado, teniendo en cuenta si hay enunciados multilínea

marca_pregunta = '+++p\n'

examen_inicial=[]
for pregunta in texto_preguntas:
    if marca_pregunta in pregunta:                      #si la pregunta es multilínea
        primercorte = pregunta.split(marca_pregunta)    #separamos la pregunta
        enunciado = primercorte.pop(0)                  #extraemos la pregunta
        enunciado = enunciado.replace('\n','</p><p>',1) #colocamos el cambio de párrafo para luego el html
        segundocorte = primercorte[0].split('\n')       #separamos las respuestas
        segundocorte.insert(0, enunciado[:-1])          #añadimos el enunciado sin el último cambio de línea
        examen_inicial.append(segundocorte)
        #print(examen_inicial)
    else:
        segundocorteB = pregunta.split('\n')            #separamos pregunta y respuestas
        examen_inicial.append(segundocorteB)            #examen como lista de listas. Primer elemento pregunta.

#print(examen_inicial)

#añadimos las preguntas al XML
xmlblank = ''''''

for idx, pregunta in enumerate(examen_inicial):
    if marca_def in texto_completo:                                 #para contemplar que no haya parámetros
        tipo_preguntas = '''<!-- PREGUNTA NÚMERO. COMENTARIO  -->
  <question type="calculatedmulti">'''

    else:
        tipo_preguntas = '''<!-- PREGUNTA NÚMERO. COMENTARIO  -->
  <question type="multichoice">'''

    temporal = tipo_preguntas + ''' 
    <name>
      <text>NOMBRE PREGUNTA</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p>ENUNCIADO</p>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>1.0000000</defaultgrade>
    <penalty>0.3333333</penalty>
    <hidden>0</hidden>
    <synchronize>0</synchronize>
    <single>1</single>
    <answernumbering>abc</answernumbering>
    <shuffleanswers>1</shuffleanswers>
    <correctfeedback>
      <text></text>
    </correctfeedback>
    <partiallycorrectfeedback>
      <text></text>
    </partiallycorrectfeedback>
    <incorrectfeedback>
      <text></text>
    </incorrectfeedback>
  '''
    ordinal = str(idx + 1) if idx >= 9 else '0'+str(idx + 1)          #para que salgan 01, 02, 03.. si, no moodle las ordena luego mal
    
    temporal = temporal.replace('PREGUNTA NÚMERO. COMENTARIO','Pregunta '+ ordinal)
    temporal = temporal.replace('NOMBRE PREGUNTA', 'Pregunta '+ ordinal)
    temporal = temporal.replace('ENUNCIADO', pregunta[0])
    
    num_respuestas = len(pregunta[1:])
    resta = round(-100/(num_respuestas-1),5)

    for idx, respuesta in enumerate(pregunta[1:]):
        temporalresp = '''<answer fraction="RESTA">
    <text>RESPUESTA</text>
    <tolerance>0.01</tolerance>
    <tolerancetype>1</tolerancetype>
    <correctanswerformat>2</correctanswerformat>
    <correctanswerlength>3</correctanswerlength>
    <feedback format="html">
<text></text>
    </feedback>
</answer>\n'''
        if idx == 0:
            temporalresp = temporalresp.replace('RESTA','100')     #respuesta correcta
        else:
            temporalresp = temporalresp.replace('RESTA', str(resta))     #respuestas incorrectas           
        
        temporalresp = temporalresp.replace('RESPUESTA', respuesta)
        
        temporal += temporalresp

       
    
    xmlblank += temporal
    
#print(xmlblank)


#Añadimos comportamiento con las unidades

    xmlblank += '''<unitgradingtype>0</unitgradingtype>
    <unitpenalty>0.1000000</unitpenalty>
    <showunits>3</showunits>
    <unitsleft>0</unitsleft>\n'''

    #print(xmlblank)

    if marca_def in texto_completo: 
      #añadimos los datasets
      xmlblank += '''<dataset_definitions>\n'''

      for variable in data:
          #print(variable)
          temporaldata = '''<dataset_definition>
      <status><text>private</text>
  </status>
      <name><text>VARIABLE</text>
  </name>
      <type>calculatedmulti</type>
      <distribution><text>uniform</text>
  </distribution>
      <minimum><text>MINIMO</text>
  </minimum>
      <maximum><text>MAXIMO</text>
  </maximum>
      <decimals><text>DECIMALES</text>
  </decimals>\n'''
          decimales = max(0, 2+math.ceil(-(math.log10(variable[1])))) #para que muestre decimales hasta la tercera cifra significativa del valor mínimo
          temporaldata = temporaldata.replace('VARIABLE', variable[0])
      
          #print(variable[1],variable[2], decimales)
      
          temporaldata = temporaldata.replace('MINIMO', str(variable[1]))
          temporaldata = temporaldata.replace('MAXIMO', str(variable[2]))
          temporaldata = temporaldata.replace('DECIMALES', str(decimales))
        
          long_serie = len(variable)-3
                  
          temporaldata += '''<itemcount>'''+str(long_serie)+'''</itemcount>
          <dataset_items>\n'''                        

      
          lista_valores = variable[3:]
          #print(lista_valores)
          
          for i, num in enumerate(lista_valores):
              temporalvalores = '''<dataset_item>
            <number>NUMERO</number>
            <value>VALOR</value>
          </dataset_item>\n'''
              temporalvalores = temporalvalores.replace('NUMERO', str(i+1))
              temporalvalores = temporalvalores.replace('VALOR', str(num))
          
              temporaldata += temporalvalores    

      
          temporaldata += '''</dataset_items>\n<number_of_items>'''+str(long_serie)+'''</number_of_items>\n'''            
          temporaldata += '''</dataset_definition>\n'''
          xmlblank += temporaldata
      
      #print(temporaldata)
      
      xmlblank += '''</dataset_definitions>\n'''
    
    xmlblank += '''</question>\n'''

#print(xmlblank)

#cerramos el cuestionario

xmlblank += '''</quiz>\n'''

#añadimos cabecera

xmlblank = '''<?xml version="1.0" encoding="UTF-8"?>\n<quiz>\n'''+ xmlblank

#print(xmlblank)

#Escribirmos el archivo de salida
# Descargamos el archivo de salida
salida = "salida.xml"   # Puede cambiarse a otro nombre

with open(salida,"w") as archivo:
  archivo.write(xmlblank)


files.download(salida)
